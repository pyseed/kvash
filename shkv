#!/bin/bash
version="0.0.1"

errorBanner="$(cat <<-EOF
error during command or command not found.
type shkv help for help."
EOF
)"

helpMessage="$(cat <<-EOF
HELP
----

help:
shkv help

set value:
shkv set key value

append:
shkv append key value

append with crlf after value:
shkv appendr key value

get key file full path:
shkv path key

remove key:
shkv del key

list add item:
shkv list add key item

list del item:
shkv list del key
if you need no duplicates: before list add you can always call list del

list foreach key callback:
item is passed as $1 in callback
export -f callback
shkv list foreach callback

dict set prop:
shkv dict set key prop value comment

dict get prop:
shkv dict get key prop

dict get props as args:
shkv dict props key
export dollar(shkv dict props key)

dict del prop:
shkv dict del key prop

EOF
)"

help () {
    echo "version: ${version}"
    echo "${helpMessage}"
    exit
}

#
# set key value
#
setVal () {
    local key="$1"
    local value="${*:2}"

    echo -n "${value}" > "${store}/${key}"
}

#
# append key value
#
append () {
    local key="$1"
    local value="${*:2}"

    echo  -n "${value}" >> "${store}/${key}"
}

#
# appendr key value
# (line after value)
#
appendr () {
    local key="$1"
    local value="${*:2}"

    echo -n "${value}" >> "${store}/${key}"
    echo "" >> "${store}/${key}"
}

#
# get key
#
get () {
    local key="$1"

    cat "${store}/${key}"
}


#
# path key
#
path () {
    local key="$1"

    echo "${store}/${key}"
}


#
# del key
#
del () {
    local key="$1"

    rm "${store}/${key}"
}


#
# list key ...args
#
list () {
    local listCommand="$1"

    declare -F "list_${listCommand}" &> /dev/null && "list_${listCommand}" ${@:2} || echo "${errorBanner}"
}

# list add key item
list_add () {
    local key="$1"
    local item="$2"

    appendr "${key}" "${item}"
}

# list del key item
list_del () {
    local key="$1"
    local item="$2"

    # IMPORTANT: match exact word ^*$ to prevent from removing entries that are not exact (like ending by prop)
    # IMPORTANT: target file can not be the source file, a pivot file is used
    cat "${store}/${key}" | (grep -v "^${item}\$" || cat "${store}/${key}") > "${store}/${key}.tmp"
    mv -f "${store}/${key}.tmp" "${store}/${key}"
}

# list for key func
list_foreach () {
    local key="$1"
    local callback="$2"

    while read item; do "${callback}" "${item}"; done < "${store}/${key}"
}


#
# list key ...args
#
dict () {
    local dictCommand="$1"
    local dictCommandFunctionName="$1"

    # command wrappers (when a command name is bash expression...)
    case "${dictCommand}" in
        set) dictCommandFunctionName="setProp";;
    esac

    declare -F "dict_${dictCommandFunctionName}" &> /dev/null && "dict_${dictCommandFunctionName}" ${@:2} || echo "${errorBanner}"
}

# set internal dict content without comments
dict_setRaw () {
   local key="$1"
   local source="${store}/${key}"
   local target="${store}/${key}_"

   cat "${source}" | (grep -v '^#' || cat "${source}") > "${target}"
}

# dict set key prop value comment
dict_setProp () {
    local key="$1"
    local prop="$2"
    local value="$3"
    local comment="${*:4}"

    list_add "${key}" "# [${prop}] $comment"
    list_add "${key}" "${prop}=${value}"
}

# dict get key prop
dict_get () {
    local key="$1"
    local prop="$2"

    # extract then export as variable
    dict_setRaw "${key}"
    export $(get "${key}_" | (grep "${prop}=" | echo ""))
    # get variable value
    echo "${!prop}"
}

# dict get key prop
dict_props () {
    local key="$1"

    dict_setRaw "${key}"
    get "${key}_" | xargs
}


# dict del key prop
dict_del () {
    local key="$1"
    local prop="$2"

    # IMPORTANT: match start word ^ to prevent from removing entries that are not exact (like ending by prop)
    # IMPORTANT: target file can not be the source file, a pivot file is used
    # remove comment
    cat "${store}/${key}" | (grep -v "^# \\[${prop}\\]" || cat "${store}/${key}") > "${store}/${key}.tmp"
    # remove value
    cat "${store}/${key}.tmp" | (grep -v "^${prop}=" || cat "${store}/${key}") > "${store}/${key}"
    rm "${store}/${key}.tmp"
}


#
# BODY
#
main () {
[ -z ${command} ] && command="help"
    store=${SHKV_STORE}
    if [ "${command}" != "help" ] && [ "${store}" = "" ]; then
        echo "aborted. target store absolute path should be pointed with SHKV_STORE environment variable"
        exit
    fi
    mkdir -p "${store}"

    # command wrappers (when a command name is bash expression...)
    case "${command}" in
        set) commandFunctionName="setVal";;
    esac

    declare -F ${commandFunctionName} &> /dev/null && ${commandFunctionName} $@ || echo "${errorBanner}"
}

command="$1"
commandFunctionName="$1"
store=${SHKV_STORE}
cwd=$(pwd)

main ${@:2}
