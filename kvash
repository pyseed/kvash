#!/bin/bash
project="kvash"
version="0.9.0"

errorBanner="$(cat <<-EOF
error during command or command not found.
type ${project} help for help."
EOF
)"

helpMessage="$(cat <<-EOF
${project} ${version}

HELP
----

location of your store (main directory path) should be set in KVASH_STORE var env
example: export KVASH_STORE="\${HOME}/kvstore/store1"

SCOPE
-----

- each key is a file, so do not use this tool as a massive storage (you do not want millions of ionodes isn't it ?)
- the goal is not to replace or mimic a 'true' key value storage
- the goal is to store embedded state when a 'true' key value storage seems overkill
- this tool helps to have list and dict types for your states in bash

TYPES
-----

- string: set/get
- list: list commands
- dict: dict commands, dicts can be exported as env variables

COMMANDS
--------

there is no explicit ${project} "clear" command, please use rm "\${KVASH_STORE}/*" to delete all the store (all the keys) 

help:
${project} help

list keys:
${project} ls [search]

touch a key
${project} touch key
will not erase content if exists

set value:
${project} set key value

append:
${project} append key value
please do not add content to a list/dict key until you know what you do

append with crlf after value:
${project} appendr key value
please do not add content to a list/dict key until you know what you do

get key file full path:
${project} path key

remove key:
${project} del key

list add item:
${project} list add key item

list del item:
${project} list del key
no duplicates expected in your use case ? before list add you can always call list del

list foreach key callback:
export -f callback
${project} list foreach callback
item is passed as \$1 in callback

dict set prop:
${project} dict set key prop value comment

dict get prop:
${project} dict get key prop
export prop=\$(${project} dict get key prop)

dict get props as args:
${project} dict props key
export \$(${project} dict props key)

dict del prop:
${project} dict del key prop

EOF
)"

help () {
    echo "${helpMessage}"
    exit
}

# check arg
# checkArg name var
checkArg () {
    if [ -z "$2" ]; then
      echo "argument missing: $1"
      exit 1
   fi
}

#
# shkv ls [search]
#
lsKeys () {
    local search="$1"

    [ -n "${search}" ] && ls -1 "${store}/${key}" | (grep "${search}" || echo "") || ls -1 "${store}/${key}"
}

#
# touch key
#
touchKey () {
    local key="$1"

    checkArg key "${key}"

    touch "${store}/${key}"
}


#
# has key
#
has () {
    local key="$1"

    checkArg key "${key}"

    [ -f "${store}/${key}" ] && echo "true" || echo "false"
}

#
# set key value
#
setVal () {
    local key="$1"
    local value="${*:2}"

    checkArg key "${key}"
    checkArg value "${value}"

    echo -n "${value}" > "${store}/${key}"
}

#
# append key value
#
append () {
    local key="$1"
    local value="${*:2}"

    checkArg key "${key}"
    checkArg value "${value}"

    echo  -n "${value}" >> "${store}/${key}"
}

#
# appendr key value
# (line after value)
#
appendr () {
    local key="$1"
    local value="${*:2}"

    checkArg key "${key}"
    checkArg value "${value}"

    echo -n "${value}" >> "${store}/${key}"
    echo "" >> "${store}/${key}"
}

#
# get key
#
get () {
    local key="$1"

    checkArg key "${key}"

    cat "${store}/${key}"
}


#
# path key
#
path () {
    local key="$1"

    checkArg key "${key}"

    echo "${store}/${key}"
}


#
# del key
#
del () {
    local key="$1"

    checkArg key "${key}"

    rm "${store}/${key}"
}


#
# list key ...args
#
list () {
    local listCommand="$1"

    checkArg command "${listCommand}"

    declare -F "list_${listCommand}" &> /dev/null && "list_${listCommand}" ${@:2} || echo "${errorBanner}"
}

# list add key item
list_add () {
    local key="$1"
    local item="$2"

    checkArg key "${key}"
    checkArg item "${item}"

    appendr "${key}" "${item}"
}

# list del key item
list_del () {
    local key="$1"
    local item="$2"

    checkArg key "${key}"
    checkArg item "${item}"

    # IMPORTANT: match exact word ^*$ to prevent from removing entries that are not exact (like ending by prop)
    # IMPORTANT: target file can not be the source file, a pivot file is used
    cat "${store}/${key}" | (grep -v "^${item}\$" || cat "${store}/${key}") > "${store}/${key}.tmp"
    mv -f "${store}/${key}.tmp" "${store}/${key}"
}

# list for key func
list_foreach () {
    local key="$1"
    local callback="$2"

    checkArg key "${key}"
    checkArg callback "${callback}"

    while read item; do "${callback}" "${item}"; done < "${store}/${key}"
}


#
# list key ...args
#
dict () {
    local dictCommand="$1"
    local dictCommandFunctionName="$1"

    checkArg command "${dictCommand}"

    # command wrappers (when a command name is bash expression...)
    case "${dictCommand}" in
        set) dictCommandFunctionName="setProp";;
    esac

    declare -F "dict_${dictCommandFunctionName}" &> /dev/null && "dict_${dictCommandFunctionName}" ${@:2} || echo "${errorBanner}"
}

# set internal dict content without comments
# dict_setRaw key targetKey
dict_setRaw () {
   local key="$1"
   local targetKey="$2"

   checkArg key "${key}"
   checkArg targetKey "${key}"

   local source="${store}/${key}"
   local target="${store}/${targetKey}"

   cat "${source}" | (grep -v '^#' || cat "${source}") > "${target}"
}

# dict set key prop value comment
dict_setProp () {
    local key="$1"
    local prop="$2"
    local value="$3"
    local comment="${*:4}"

    checkArg key "${key}"
    checkArg prop "${prop}"
    checkArg value "${value}"
    checkArg comment "${comment}"

    list_add "${key}" "# [${prop}] $comment"
    list_add "${key}" "${prop}=${value}"
}

# dict get key prop
dict_get () {
    local key="$1"
    local prop="$2"

    checkArg key "${key}"
    checkArg prop "${prop}"

    # extract then export as variable
    dict_setRaw "${key}" ".${key}"
    export $(get ".${key}" | (grep "^${prop}=" || echo ""))
    del ".${key}"

    # get variable value
    echo "${!prop}"
}

# dict get key prop
dict_props () {
    local key="$1"

    checkArg key "${key}"

    dict_setRaw "${key}" ".${key}"
    get ".${key}" | xargs
    del ".${key}"
}


# dict del key prop
dict_del () {
    local key="$1"
    local prop="$2"

    checkArg key "${key}"
    checkArg prop "${prop}"

    # IMPORTANT: match start word ^ to prevent from removing entries that are not exact (like ending by prop)
    # IMPORTANT: target file can not be the source file, a pivot file is used
    # remove comment
    cat "${store}/${key}" | (grep -v "^# \\[${prop}\\]" || cat "${store}/${key}") > "${store}/.${key}"
    # remove value
    cat "${store}/.${key}" | (grep -v "^${prop}=" || cat "${store}/${key}") > "${store}/${key}"
    del ".${key}"
}


#
# BODY
#
main () {
[ -z ${command} ] && command="help"
    store=${KVASH_STORE}

    if [ "${command}" != "help" ] && [ -z "${store}" ]; then
        echo "aborted. target store absolute path should be pointed with KVASH_STORE environment variable"
        exit
    fi

    [ "${command}" != "help" ] && mkdir -p "${store}"

    # command wrappers (when a command name is bash expression...)
    case "${command}" in
        ls) commandFunctionName="lsKeys";;
        touch)  commandFunctionName="touchKey";;
        set) commandFunctionName="setVal";;
    esac

    declare -F ${commandFunctionName} &> /dev/null && ${commandFunctionName} $@ || echo "${errorBanner}"
}

command="$1"
commandFunctionName="$1"
store=${KVASH_STORE}
cwd=$(pwd)

main ${@:2}
